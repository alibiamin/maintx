import React, { useState, useEffect } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  Button,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
  LinearProgress,
  List,
  ListItem,
  ListItemText
} from '@mui/material';
import { Upload as UploadIcon } from '@mui/icons-material';
import { useTranslation } from 'react-i18next';
import api from '../services/api';

export default function ExploitationImport() {
  const { t } = useTranslation();
  const [templates, setTemplates] = useState([]);
  const [entity, setEntity] = useState('');
  const [file, setFile] = useState(null);
  const [loading, setLoading] = useState(true);
  const [submitting, setSubmitting] = useState(false);
  const [result, setResult] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    let cancelled = false;
    api.get('/exploitation/templates')
      .then((res) => { if (!cancelled) setTemplates(res.data || []); })
      .catch((err) => { if (!cancelled) setError(err.response?.data?.error || err.message); })
      .finally(() => { if (!cancelled) setLoading(false); });
    return () => { cancelled = true; };
  }, []);

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!entity || !file) {
      setError(t('exploitation.requiredEntityFile'));
      return;
    }
    setError(null);
    setResult(null);
    setSubmitting(true);
    try {
      const formData = new FormData();
      formData.append('entity', entity);
      formData.append('file', file);
      const res = await api.post('/exploitation/import', formData, {
        headers: { 'Content-Type': 'multipart/form-data' }
      });
      setResult(res.data);
      setFile(null);
    } catch (err) {
      setError(err.response?.data?.error || err.response?.data?.message || err.message || 'Erreur import');
    } finally {
      setSubmitting(false);
    }
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight={200}>
        <LinearProgress sx={{ width: 200 }} />
      </Box>
    );
  }

  return (
    <Box>
      <Typography variant="h5" fontWeight={700} sx={{ mb: 3 }}>
        {t('item.exploitation_import')}
      </Typography>
      <Typography color="text.secondary" sx={{ mb: 2 }}>
        {t('exploitation.importHint')}
      </Typography>
      {error && (
        <Alert severity="error" onClose={() => setError(null)} sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}
      {result && (
        <Alert severity="success" onClose={() => setResult(null)} sx={{ mb: 2 }}>
          {t('exploitation.successCount', { count: result.inserted })} {result.errors > 0 && t('exploitation.errorCount', { count: result.errors })}
        </Alert>
      )}
      <Card sx={{ borderRadius: 2 }}>
        <CardContent>
          <form onSubmit={handleSubmit}>
            <FormControl fullWidth sx={{ mb: 2 }} required>
              <InputLabel>Table (entité)</InputLabel>
              <Select
                value={entity}
                label="Table (entité)"
                onChange={(e) => setEntity(e.target.value)}
              >
                {templates.map((item) => (
                  <MenuItem key={item.id} value={item.id}>{item.label}</MenuItem>
                ))}
              </Select>
            </FormControl>
            <FormControl fullWidth sx={{ mb: 2 }} required>
              <Button variant="outlined" component="label" startIcon={<UploadIcon />}>
                {file ? file.name : t('exploitation.chooseFile')}
                <input type="file" hidden accept=".xlsx,.xls" onChange={(e) => setFile(e.target.files?.[0] || null)} />
              </Button>
            </FormControl>
            <Button type="submit" variant="contained" disabled={submitting || !entity || !file}>
              {submitting ? t('exploitation.importing') : t('exploitation.importButton')}
            </Button>
          </form>
          {result && result.details?.errors?.length > 0 && (
            <Box sx={{ mt: 2 }}>
              <Typography variant="subtitle2" color="error">{t('exploitation.errorsExtract')}</Typography>
              <List dense>
                {result.details.errors.slice(0, 10).map((err, i) => (
                  <ListItem key={i}>
                    <ListItemText primary={t('exploitation.rowError', { row: err.row, message: err.message })} />
                  </ListItem>
                ))}
              </List>
            </Box>
          )}
        </CardContent>
      </Card>
    </Box>
  );
}
