/**
 * API Exploitation - Exportation de modèles Excel et importation de données
 * L'utilisateur exporte la structure (template) d'une table, remplit le fichier, puis l'importe.
 */

const express = require('express');
const ExcelJS = require('exceljs');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const { authenticate, authorize, ROLES } = require('../middleware/auth');

const router = express.Router();
router.use(authenticate);

const uploadsDir = path.join(__dirname, '../../uploads/exploitation');
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}

const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, uploadsDir),
  filename: (req, file, cb) => cb(null, Date.now() + '-' + (file.originalname || 'import.xlsx'))
});
const upload = multer({
  storage,
  limits: { fileSize: 10 * 1024 * 1024 },
  fileFilter: (req, file, cb) => {
    const ext = (path.extname(file.originalname || '') || '').toLowerCase();
    if (['.xlsx', '.xls'].includes(ext)) return cb(null, true);
    cb(new Error('Seuls les fichiers Excel (.xlsx, .xls) sont acceptés'));
  }
});

/** Définition des entités exportables / importables : sheetName, libellé, colonnes Excel (header => colonne BDD ou règle) */
const ENTITIES = {
  sites: {
    label: 'Sites',
    sheetName: 'Sites',
    columns: [
      { header: 'code', key: 'code', width: 18 },
      { header: 'name', key: 'name', width: 30 },
      { header: 'address', key: 'address', width: 40 }
    ],
    table: 'sites',
    insertCols: ['code', 'name', 'address']
  },
  departements: {
    label: 'Départements',
    sheetName: 'Departements',
    columns: [
      { header: 'site_code', key: 'site_code', width: 18 },
      { header: 'code', key: 'code', width: 18 },
      { header: 'name', key: 'name', width: 30 },
      { header: 'description', key: 'description', width: 40 }
    ],
    table: 'departements',
    insertCols: ['site_id', 'code', 'name', 'description'],
    resolveRefs: { site_id: { table: 'sites', by: 'code' } }
  },
  lignes: {
    label: 'Lignes',
    sheetName: 'Lignes',
    columns: [
      { header: 'site_code', key: 'site_code', width: 18 },
      { header: 'code', key: 'code', width: 18 },
      { header: 'name', key: 'name', width: 30 }
    ],
    table: 'lignes',
    insertCols: ['site_id', 'code', 'name'],
    resolveRefs: { site_id: { table: 'sites', by: 'code' } }
  },
  suppliers: {
    label: 'Fournisseurs',
    sheetName: 'Fournisseurs',
    columns: [
      { header: 'code', key: 'code', width: 18 },
      { header: 'name', key: 'name', width: 30 },
      { header: 'contact_person', key: 'contact_person', width: 20 },
      { header: 'email', key: 'email', width: 25 },
      { header: 'phone', key: 'phone', width: 15 },
      { header: 'address', key: 'address', width: 40 }
    ],
    table: 'suppliers',
    insertCols: ['code', 'name', 'contact_person', 'email', 'phone', 'address']
  },
  spare_parts: {
    label: 'Pièces détachées (stock)',
    sheetName: 'Pieces',
    columns: [
      { header: 'code', key: 'code', width: 18 },
      { header: 'name', key: 'name', width: 30 },
      { header: 'description', key: 'description', width: 40 },
      { header: 'unit_id', key: 'unit_id', width: 12 },
      { header: 'unit_price', key: 'unit_price', width: 12 },
      { header: 'min_stock', key: 'min_stock', width: 12 },
      { header: 'supplier_code', key: 'supplier_code', width: 18 },
      { header: 'location', key: 'location', width: 20 }
    ],
    table: 'spare_parts',
    insertCols: ['code', 'name', 'description', 'unit_id', 'unit_price', 'min_stock', 'supplier_id', 'location'],
    resolveRefs: { supplier_id: { table: 'suppliers', by: 'code' } }
  },
  equipment_categories: {
    label: 'Catégories d\'équipements',
    sheetName: 'CategoriesEquipements',
    columns: [
      { header: 'name', key: 'name', width: 30 },
      { header: 'description', key: 'description', width: 40 }
    ],
    table: 'equipment_categories',
    insertCols: ['name', 'description']
  },
  failure_codes: {
    label: 'Codes défaut',
    sheetName: 'CodesDefaut',
    columns: [
      { header: 'code', key: 'code', width: 18 },
      { header: 'name', key: 'name', width: 35 },
      { header: 'description', key: 'description', width: 40 },
      { header: 'category', key: 'category', width: 20 }
    ],
    table: 'failure_codes',
    insertCols: ['code', 'name', 'description', 'category']
  }
};

/**
 * GET /api/exploitation/templates
 * Liste des modèles exportables
 */
router.get('/templates', (req, res) => {
  const list = Object.entries(ENTITIES).map(([id, cfg]) => ({
    id,
    label: cfg.label,
    sheetName: cfg.sheetName
  }));
  res.json(list);
});

/**
 * GET /api/exploitation/export/:entity
 * Télécharge un fichier Excel template (en-têtes uniquement) pour l'entité
 */
router.get('/export/:entity', authorize(ROLES.ADMIN, ROLES.RESPONSABLE), async (req, res) => {
  const entity = req.params.entity;
  const config = ENTITIES[entity];
  if (!config) {
    return res.status(404).json({ error: 'Entité non supportée pour l\'export' });
  }

  const workbook = new ExcelJS.Workbook();
  const sheet = workbook.addWorksheet(config.sheetName);
  sheet.columns = config.columns.map(c => ({ header: c.header, key: c.key, width: c.width || 15 }));
  sheet.addRow({}); // ligne vide pour remplir

  res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
  res.setHeader('Content-Disposition', `attachment; filename=template-${entity}.xlsx`);

  await workbook.xlsx.write(res);
  res.end();
});

/**
 * POST /api/exploitation/import
 * Importe un fichier Excel (multipart). Body: entity = identifiant de l'entité (sites, suppliers, ...)
 */
router.post('/import', authorize(ROLES.ADMIN, ROLES.RESPONSABLE), upload.single('file'), async (req, res) => {
  const db = req.db;
  if (!db) return res.status(401).json({ error: 'Authentification requise' });

  const entity = (req.body && req.body.entity) || (req.body && req.body.entityId);
  if (!entity) {
    return res.status(400).json({ error: 'Paramètre entity requis (sites, suppliers, spare_parts, etc.)' });
  }

  const config = ENTITIES[entity];
  if (!config) {
    return res.status(400).json({ error: `Entité "${entity}" non supportée pour l'import` });
  }

  const file = req.file;
  if (!file || !file.path) {
    return res.status(400).json({ error: 'Aucun fichier envoyé' });
  }

  try {
    const workbook = new ExcelJS.Workbook();
    await workbook.xlsx.readFile(file.path);
    const sheet = workbook.getWorksheet(config.sheetName) || workbook.worksheets[0];
    if (!sheet) {
      fs.unlink(file.path, () => {});
      return res.status(400).json({ error: 'Feuille non trouvée dans le fichier. Utilisez le modèle exporté.' });
    }

    const headerRow = sheet.getRow(1);
    const headers = [];
    headerRow.eachCell((cell, colNumber) => {
      const val = cell && cell.value != null ? String(cell.value).trim() : '';
      if (val) headers[colNumber - 1] = val;
    });

    const keyToCol = {};
    config.columns.forEach((col, idx) => {
      const h = col.header;
      const i = headers.findIndex(hi => (hi || '').toLowerCase() === (h || '').toLowerCase());
      if (i >= 0) keyToCol[col.key] = i;
    });

    const inserted = [];
    const errors = [];
    const resolveRef = (refKey, value, rowIndex) => {
      if (value == null || value === '') return null;
      const ref = config.resolveRefs && config.resolveRefs[refKey];
      if (!ref) return value;
      const r = db.prepare(`SELECT id FROM ${ref.table} WHERE ${ref.by} = ?`).get(String(value).trim());
      return r ? r.id : null;
    };

    for (let rowIndex = 2; rowIndex <= sheet.rowCount; rowIndex++) {
      const row = sheet.getRow(rowIndex);
      const values = {};
      let hasAny = false;
      config.columns.forEach(col => {
        const colIdx = keyToCol[col.key];
        let val = colIdx != null && row.getCell(colIdx + 1).value != null
          ? row.getCell(colIdx + 1).value
          : null;
        if (val != null && typeof val === 'object' && val.result != null) val = val.result;
        if (val != null && val !== '') {
          hasAny = true;
          values[col.key] = typeof val === 'string' ? val.trim() : val;
        }
      });

      if (!hasAny) continue;

      try {
        const insertRow = {};
        config.insertCols.forEach(insertCol => {
          const ref = config.resolveRefs && config.resolveRefs[insertCol];
          if (ref) {
            const excelKey = (ref.excelKey != null) ? ref.excelKey : insertCol.replace(/_id$/, '_code');
            const codeVal = values[excelKey];
            insertRow[insertCol] = resolveRef(insertCol, codeVal, rowIndex);
          } else {
            const v = values[insertCol];
            if (v !== undefined && v !== null && v !== '') insertRow[insertCol] = v;
          }
        });

        const cols = Object.keys(insertRow).filter(k => insertRow[k] !== undefined && insertRow[k] !== '');
        if (cols.length === 0) {
          errors.push({ row: rowIndex, message: 'Aucune valeur valide' });
          continue;
        }

        const placeholders = cols.map(() => '?').join(', ');
        const sql = `INSERT INTO ${config.table} (${cols.join(', ')}) VALUES (${placeholders})`;
        db.prepare(sql).run(...cols.map(c => insertRow[c]));
        inserted.push({ row: rowIndex, data: insertRow });
      } catch (err) {
        errors.push({ row: rowIndex, message: err.message || 'Erreur insertion' });
      }
    }

    if (db._save) db._save();
    fs.unlink(file.path, () => {});

    res.json({
      success: true,
      inserted: inserted.length,
      errors: errors.length,
      details: { inserted: inserted.slice(0, 50), errors: errors.slice(0, 20) }
    });
  } catch (err) {
    if (file && file.path && fs.existsSync(file.path)) fs.unlink(file.path, () => {});
    console.error('Exploitation import error:', err);
    res.status(500).json({ error: 'Erreur lors de la lecture du fichier Excel', message: err.message });
  }
});

module.exports = router;
