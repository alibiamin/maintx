/**
 * API Exploitation - Export / Import de données en masse
 * Respect des colonnes NOT NULL, clés primaires et clés étrangères.
 */

const express = require('express');
const ExcelJS = require('exceljs');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const { authenticate, authorize, ROLES } = require('../middleware/auth');

const router = express.Router();
router.use(authenticate);

const uploadsDir = path.join(__dirname, '../../uploads/exploitation');
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}

const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, uploadsDir),
  filename: (req, file, cb) => cb(null, Date.now() + '-' + (file.originalname || 'import.xlsx').replace(/[^a-zA-Z0-9._-]/g, '_'))
});
const upload = multer({
  storage,
  limits: { fileSize: 15 * 1024 * 1024 },
  fileFilter: (req, file, cb) => {
    const ext = (path.extname(file.originalname || '') || '').toLowerCase();
    if (['.xlsx', '.xls'].includes(ext)) return cb(null, true);
    cb(new Error('Seuls les fichiers Excel (.xlsx, .xls) sont acceptés'));
  }
});

/**
 * Définition des entités importables/exportables.
 * - requiredColumns: colonnes obligatoires (NOT NULL sans défaut ou clé métier)
 * - insertCols: colonnes utilisées à l'insert (ordre et mapping)
 * - resolveRefs: colonne_id => { table, by } pour résoudre une clé étrangère via une colonne Excel (ex: site_code -> sites.id)
 * - excelKey: nom de la colonne dans le fichier pour une FK (défaut: *_code ou nom explicite)
 */
const ENTITIES = {
  sites: {
    label: 'Sites',
    sheetName: 'Sites',
    table: 'sites',
    requiredColumns: ['code', 'name'],
    insertCols: ['code', 'name', 'address'],
    columns: [
      { header: 'code', key: 'code', width: 18 },
      { header: 'name', key: 'name', width: 30 },
      { header: 'address', key: 'address', width: 40 }
    ]
  },
  lignes: {
    label: 'Lignes',
    sheetName: 'Lignes',
    table: 'lignes',
    requiredColumns: ['site_code', 'code', 'name'],
    insertCols: ['site_id', 'code', 'name'],
    resolveRefs: { site_id: { table: 'sites', by: 'code', excelKey: 'site_code' } },
    columns: [
      { header: 'site_code', key: 'site_code', width: 18 },
      { header: 'code', key: 'code', width: 18 },
      { header: 'name', key: 'name', width: 30 }
    ]
  },
  departements: {
    label: 'Départements',
    sheetName: 'Departements',
    table: 'departements',
    requiredColumns: ['site_code', 'code', 'name'],
    insertCols: ['site_id', 'code', 'name', 'description'],
    resolveRefs: { site_id: { table: 'sites', by: 'code', excelKey: 'site_code' } },
    columns: [
      { header: 'site_code', key: 'site_code', width: 18 },
      { header: 'code', key: 'code', width: 18 },
      { header: 'name', key: 'name', width: 30 },
      { header: 'description', key: 'description', width: 40 }
    ]
  },
  equipment_categories: {
    label: 'Catégories d\'équipements',
    sheetName: 'CategoriesEquipements',
    table: 'equipment_categories',
    requiredColumns: ['name'],
    insertCols: ['name', 'description', 'parent_id'],
    resolveRefs: { parent_id: { table: 'equipment_categories', by: 'id', excelKey: 'parent_id' } },
    columns: [
      { header: 'name', key: 'name', width: 30 },
      { header: 'description', key: 'description', width: 40 },
      { header: 'parent_id', key: 'parent_id', width: 12 }
    ]
  },
  units: {
    label: 'Unités',
    sheetName: 'Units',
    table: 'units',
    requiredColumns: ['name'],
    insertCols: ['name', 'symbol'],
    columns: [
      { header: 'name', key: 'name', width: 20 },
      { header: 'symbol', key: 'symbol', width: 12 }
    ]
  },
  suppliers: {
    label: 'Fournisseurs',
    sheetName: 'Fournisseurs',
    table: 'suppliers',
    requiredColumns: ['code', 'name'],
    insertCols: ['code', 'name', 'contact_person', 'email', 'phone', 'address'],
    columns: [
      { header: 'code', key: 'code', width: 18 },
      { header: 'name', key: 'name', width: 30 },
      { header: 'contact_person', key: 'contact_person', width: 20 },
      { header: 'email', key: 'email', width: 25 },
      { header: 'phone', key: 'phone', width: 15 },
      { header: 'address', key: 'address', width: 40 }
    ]
  },
  spare_parts: {
    label: 'Pièces détachées',
    sheetName: 'Pieces',
    table: 'spare_parts',
    requiredColumns: ['code', 'name'],
    insertCols: ['code', 'name', 'description', 'unit_id', 'unit_price', 'min_stock', 'supplier_id', 'location'],
    resolveRefs: {
      supplier_id: { table: 'suppliers', by: 'code', excelKey: 'supplier_code' },
      unit_id: { table: 'units', by: 'name', excelKey: 'unit_name' }
    },
    columns: [
      { header: 'code', key: 'code', width: 18 },
      { header: 'name', key: 'name', width: 30 },
      { header: 'description', key: 'description', width: 40 },
      { header: 'unit_name', key: 'unit_name', width: 18 },
      { header: 'unit_price', key: 'unit_price', width: 12 },
      { header: 'min_stock', key: 'min_stock', width: 12 },
      { header: 'supplier_code', key: 'supplier_code', width: 18 },
      { header: 'location', key: 'location', width: 20 }
    ]
  },
  equipment: {
    label: 'Équipements',
    sheetName: 'Equipements',
    table: 'equipment',
    requiredColumns: ['code', 'name'],
    insertCols: ['code', 'name', 'description', 'category_id', 'ligne_id', 'department_id', 'serial_number', 'criticite', 'manufacturer', 'model', 'installation_date', 'location', 'status'],
    resolveRefs: {
      category_id: { table: 'equipment_categories', by: 'id', excelKey: 'category_id' },
      ligne_id: { table: 'lignes', by: 'code', excelKey: 'ligne_code' },
      department_id: { table: 'departements', by: 'code', excelKey: 'department_code' }
    },
    columns: [
      { header: 'code', key: 'code', width: 18 },
      { header: 'name', key: 'name', width: 30 },
      { header: 'description', key: 'description', width: 40 },
      { header: 'category_id', key: 'category_id', width: 12 },
      { header: 'ligne_code', key: 'ligne_code', width: 18 },
      { header: 'department_code', key: 'department_code', width: 18 },
      { header: 'serial_number', key: 'serial_number', width: 20 },
      { header: 'criticite', key: 'criticite', width: 10 },
      { header: 'manufacturer', key: 'manufacturer', width: 20 },
      { header: 'model', key: 'model', width: 20 },
      { header: 'installation_date', key: 'installation_date', width: 14 },
      { header: 'location', key: 'location', width: 20 },
      { header: 'status', key: 'status', width: 14 }
    ]
  },
  failure_codes: {
    label: 'Codes défaut',
    sheetName: 'CodesDefaut',
    table: 'failure_codes',
    requiredColumns: ['code', 'name'],
    insertCols: ['code', 'name', 'description', 'category'],
    columns: [
      { header: 'code', key: 'code', width: 18 },
      { header: 'name', key: 'name', width: 35 },
      { header: 'description', key: 'description', width: 40 },
      { header: 'category', key: 'category', width: 20 }
    ]
  },
  part_families: {
    label: 'Familles de pièces',
    sheetName: 'FamillesPieces',
    table: 'part_families',
    requiredColumns: ['code', 'name'],
    insertCols: ['code', 'name', 'description'],
    columns: [
      { header: 'code', key: 'code', width: 18 },
      { header: 'name', key: 'name', width: 30 },
      { header: 'description', key: 'description', width: 40 }
    ]
  },
  brands: {
    label: 'Marques',
    sheetName: 'Marques',
    table: 'brands',
    requiredColumns: ['code', 'name'],
    insertCols: ['code', 'name', 'description'],
    columns: [
      { header: 'code', key: 'code', width: 18 },
      { header: 'name', key: 'name', width: 30 },
      { header: 'description', key: 'description', width: 40 }
    ]
  },
  work_order_types: {
    label: 'Types d\'OT',
    sheetName: 'TypesOT',
    table: 'work_order_types',
    requiredColumns: ['name'],
    insertCols: ['name', 'color'],
    columns: [
      { header: 'name', key: 'name', width: 20 },
      { header: 'color', key: 'color', width: 12 }
    ]
  },
  standards: {
    label: 'Normes (bibliothèque)',
    sheetName: 'Normes',
    table: 'standards',
    requiredColumns: ['code', 'title'],
    insertCols: ['code', 'title', 'description', 'domain', 'standard_type', 'organization', 'document_url', 'objectives', 'sectors_equipment', 'version_history'],
    columns: [
      { header: 'code', key: 'code', width: 18 },
      { header: 'title', key: 'title', width: 40 },
      { header: 'description', key: 'description', width: 50 },
      { header: 'domain', key: 'domain', width: 25 },
      { header: 'standard_type', key: 'standard_type', width: 20 },
      { header: 'organization', key: 'organization', width: 12 },
      { header: 'document_url', key: 'document_url', width: 40 },
      { header: 'objectives', key: 'objectives', width: 40 },
      { header: 'sectors_equipment', key: 'sectors_equipment', width: 40 },
      { header: 'version_history', key: 'version_history', width: 30 }
    ]
  }
};

/** Ordre d'import recommandé (tables sans FK d'abord, puis dépendantes). */
const IMPORT_ORDER = [
  'sites', 'equipment_categories', 'units', 'suppliers', 'failure_codes', 'part_families', 'brands', 'work_order_types', 'standards',
  'lignes', 'departements',
  'spare_parts', 'equipment'
];

/**
 * GET /api/exploitation/templates
 * Liste des modèles avec métadonnées (colonnes obligatoires, clés étrangères).
 */
router.get('/templates', (req, res) => {
  const list = IMPORT_ORDER.filter((id) => ENTITIES[id]).map((id) => {
    const cfg = ENTITIES[id];
    const required = cfg.requiredColumns || [];
    const fkList = cfg.resolveRefs
      ? Object.entries(cfg.resolveRefs).map(([col, ref]) => ({ column: col, table: ref.table, refBy: ref.by, excelKey: ref.excelKey || col.replace(/_id$/, '_code') }))
      : [];
    return {
      id,
      label: cfg.label,
      sheetName: cfg.sheetName,
      table: cfg.table,
      requiredColumns: required,
      foreignKeys: fkList,
      importOrder: IMPORT_ORDER.indexOf(id) + 1
    };
  });
  res.json(list);
});

/**
 * GET /api/exploitation/schema/:entity
 * Détail du schéma d'une entité (colonnes, obligatoires, FK).
 */
router.get('/schema/:entity', (req, res) => {
  const config = ENTITIES[req.params.entity];
  if (!config) return res.status(404).json({ error: 'Entité non supportée' });
  const required = config.requiredColumns || [];
  const foreignKeys = config.resolveRefs
    ? Object.entries(config.resolveRefs).map(([col, ref]) => ({
      column: col,
      referencedTable: ref.table,
      lookupBy: ref.by,
      excelColumn: ref.excelKey || col.replace(/_id$/, '_code')
    }))
    : [];
  res.json({
    id: req.params.entity,
    label: config.label,
    table: config.table,
    requiredColumns: required,
    optionalColumns: (config.insertCols || []).filter((c) => !required.includes(c) && !config.resolveRefs?.[c]),
    foreignKeys,
    columns: config.columns
  });
});

/**
 * GET /api/exploitation/export/:entity
 * Télécharge un modèle Excel (en-têtes + feuille Instructions).
 */
router.get('/export/:entity', authorize(ROLES.ADMIN, ROLES.RESPONSABLE), async (req, res) => {
  const entity = req.params.entity;
  const config = ENTITIES[entity];
  if (!config) return res.status(404).json({ error: 'Entité non supportée pour l\'export' });

  const workbook = new ExcelJS.Workbook();
  const sheet = workbook.addWorksheet(config.sheetName, { properties: { tabColor: { argb: 'FF2196F3' } } });
  sheet.columns = config.columns.map((c) => ({ header: c.header, key: c.key, width: c.width || 15 }));
  sheet.addRow({});

  const required = config.requiredColumns || [];
  const fkList = config.resolveRefs
    ? Object.entries(config.resolveRefs).map(([col, ref]) => `  - ${ref.excelKey || col}: référence ${ref.table} (par ${ref.by})`)
    : [];
  const instructions = workbook.addWorksheet('Instructions', { properties: { tabColor: { argb: 'FFFF9800' } } });
  instructions.columns = [{ header: 'Règle', key: 'rule', width: 80 }];
  instructions.addRow({ rule: `Table: ${config.label} (${config.table})` });
  instructions.addRow({ rule: '' });
  instructions.addRow({ rule: 'Colonnes OBLIGATOIRES (non vides):' });
  required.forEach((r) => instructions.addRow({ rule: `  - ${r}` }));
  if (fkList.length) {
    instructions.addRow({ rule: '' });
    instructions.addRow({ rule: 'Références (clés étrangères - la valeur doit exister dans la table indiquée):' });
    fkList.forEach((line) => instructions.addRow({ rule: line }));
  }
  instructions.addRow({ rule: '' });
  instructions.addRow({ rule: 'Remplissez la feuille de données (première feuille), sauvegardez puis importez via Importation des données.' });

  res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
  res.setHeader('Content-Disposition', `attachment; filename=template-${entity}.xlsx`);
  await workbook.xlsx.write(res);
  res.end();
});

/**
 * Résout une clé étrangère à partir de la config et de la valeur Excel.
 */
function resolveForeignKey(db, config, refKey, value, rowIndex) {
  if (value == null || value === '') return null;
  const ref = config.resolveRefs && config.resolveRefs[refKey];
  if (!ref) return value;
  const excelKey = ref.excelKey || refKey.replace(/_id$/, '_code');
  const raw = String(value).trim();
  try {
    const r = db.prepare(`SELECT id FROM ${ref.table} WHERE ${ref.by} = ?`).get(raw);
    return r ? r.id : null;
  } catch (e) {
    return null;
  }
}

/**
 * POST /api/exploitation/import
 * Import avec validation NOT NULL et résolution des FK.
 */
router.post('/import', authorize(ROLES.ADMIN, ROLES.RESPONSABLE), upload.single('file'), async (req, res) => {
  const db = req.db;
  if (!db) return res.status(401).json({ error: 'Authentification requise' });

  const entity = (req.body && req.body.entity) || (req.body && req.body.entityId);
  if (!entity) {
    return res.status(400).json({ error: 'Paramètre entity requis' });
  }

  const config = ENTITIES[entity];
  if (!config) {
    return res.status(400).json({ error: `Entité "${entity}" non supportée pour l'import` });
  }

  const file = req.file;
  if (!file || !file.path) {
    return res.status(400).json({ error: 'Aucun fichier envoyé' });
  }

  const requiredColumns = config.requiredColumns || [];
  const excelKeyForInsert = {};
  config.insertCols.forEach((insertCol) => {
    const ref = config.resolveRefs && config.resolveRefs[insertCol];
    if (ref) excelKeyForInsert[insertCol] = ref.excelKey || insertCol.replace(/_id$/, '_code');
    else excelKeyForInsert[insertCol] = insertCol;
  });

  try {
    const workbook = new ExcelJS.Workbook();
    await workbook.xlsx.readFile(file.path);
    const sheet = workbook.getWorksheet(config.sheetName) || workbook.worksheets[0];
    if (!sheet) {
      fs.unlink(file.path, () => {});
      return res.status(400).json({ error: 'Feuille non trouvée. Utilisez le modèle téléchargé (même nom de feuille).' });
    }

    const headerRow = sheet.getRow(1);
    const headers = [];
    headerRow.eachCell((cell, colNumber) => {
      const val = cell && cell.value != null ? String(cell.value).trim() : '';
      if (val) headers[colNumber - 1] = val;
    });

    const keyToCol = {};
    (config.columns || []).forEach((col) => {
      const key = col.key || col.header;
      const i = headers.findIndex((hi) => (hi || '').toLowerCase() === (key || '').toLowerCase());
      if (i >= 0) keyToCol[key] = i;
    });

    const inserted = [];
    const errors = [];

    for (let rowIndex = 2; rowIndex <= sheet.rowCount; rowIndex++) {
      const row = sheet.getRow(rowIndex);
      const values = {};
      (config.columns || []).forEach((col) => {
        const key = col.key || col.header;
        const colIdx = keyToCol[key];
        let val = colIdx != null && row.getCell(colIdx + 1).value != null ? row.getCell(colIdx + 1).value : null;
        if (val != null && typeof val === 'object' && val.result != null) val = val.result;
        if (val != null && val !== '') values[key] = typeof val === 'string' ? val.trim() : val;
      });

      const hasAny = Object.keys(values).length > 0;
      if (!hasAny) continue;

      const missingRequired = requiredColumns.filter((r) => {
        const excelKey = excelKeyForInsert[r] || r;
        const v = values[excelKey];
        return v === undefined || v === null || v === '';
      });
      if (missingRequired.length > 0) {
        errors.push({ row: rowIndex, message: `Colonnes obligatoires manquantes ou vides: ${missingRequired.join(', ')}` });
        continue;
      }

      try {
        const insertRow = {};
        let hasFkError = false;
        for (const insertCol of config.insertCols) {
          const excelKey = excelKeyForInsert[insertCol];
          const rawVal = values[excelKey];
          if (config.resolveRefs && config.resolveRefs[insertCol]) {
            const resolved = resolveForeignKey(db, config, insertCol, rawVal, rowIndex);
            if (resolved !== undefined && resolved !== null) {
              insertRow[insertCol] = resolved;
            } else if (rawVal != null && rawVal !== '') {
              const ref = config.resolveRefs[insertCol];
              errors.push({ row: rowIndex, message: `Référence invalide: ${excelKey}=${rawVal} (aucun enregistrement dans ${ref.table}.${ref.by})` });
              hasFkError = true;
            }
          } else {
            if (rawVal !== undefined && rawVal !== null && rawVal !== '') insertRow[insertCol] = rawVal;
          }
        }
        if (hasFkError) continue;

        const cols = Object.keys(insertRow).filter((k) => insertRow[k] !== undefined && insertRow[k] !== '');
        if (cols.length === 0) {
          errors.push({ row: rowIndex, message: 'Aucune valeur valide' });
          continue;
        }

        const placeholders = cols.map(() => '?').join(', ');
        const sql = `INSERT INTO ${config.table} (${cols.join(', ')}) VALUES (${placeholders})`;
        db.prepare(sql).run(...cols.map((c) => insertRow[c]));
        inserted.push({ row: rowIndex, data: insertRow });
      } catch (err) {
        const msg = err.message || 'Erreur insertion';
        const isUnique = msg.includes('UNIQUE') || msg.includes('unique') || msg.includes('duplicate');
        errors.push({ row: rowIndex, message: isUnique ? `Doublon ou valeur unique déjà existante: ${msg}` : msg });
      }
    }

    if (db._save) db._save();
    fs.unlink(file.path, () => {});

    res.json({
      success: true,
      inserted: inserted.length,
      errors: errors.length,
      details: {
        inserted: inserted.slice(0, 100),
        errors: errors.slice(0, 100)
      }
    });
  } catch (err) {
    if (file && file.path && fs.existsSync(file.path)) fs.unlink(file.path, () => {});
    console.error('Exploitation import error:', err);
    res.status(500).json({ error: 'Erreur lors de la lecture du fichier Excel', message: err.message });
  }
});

module.exports = router;
